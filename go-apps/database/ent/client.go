// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/yekta/stablecog/go-apps/database/ent/migrate"

	"github.com/yekta/stablecog/go-apps/database/ent/admin"
	"github.com/yekta/stablecog/go-apps/database/ent/generation"
	"github.com/yekta/stablecog/go-apps/database/ent/generationg"
	"github.com/yekta/stablecog/go-apps/database/ent/generationrealtime"
	"github.com/yekta/stablecog/go-apps/database/ent/model"
	"github.com/yekta/stablecog/go-apps/database/ent/negativeprompt"
	"github.com/yekta/stablecog/go-apps/database/ent/prompt"
	"github.com/yekta/stablecog/go-apps/database/ent/scheduler"
	"github.com/yekta/stablecog/go-apps/database/ent/server"
	"github.com/yekta/stablecog/go-apps/database/ent/upscale"
	"github.com/yekta/stablecog/go-apps/database/ent/upscalerealtime"
	"github.com/yekta/stablecog/go-apps/database/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Admin is the client for interacting with the Admin builders.
	Admin *AdminClient
	// Generation is the client for interacting with the Generation builders.
	Generation *GenerationClient
	// GenerationG is the client for interacting with the GenerationG builders.
	GenerationG *GenerationGClient
	// GenerationRealtime is the client for interacting with the GenerationRealtime builders.
	GenerationRealtime *GenerationRealtimeClient
	// Model is the client for interacting with the Model builders.
	Model *ModelClient
	// NegativePrompt is the client for interacting with the NegativePrompt builders.
	NegativePrompt *NegativePromptClient
	// Prompt is the client for interacting with the Prompt builders.
	Prompt *PromptClient
	// Scheduler is the client for interacting with the Scheduler builders.
	Scheduler *SchedulerClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// Upscale is the client for interacting with the Upscale builders.
	Upscale *UpscaleClient
	// UpscaleRealtime is the client for interacting with the UpscaleRealtime builders.
	UpscaleRealtime *UpscaleRealtimeClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Admin = NewAdminClient(c.config)
	c.Generation = NewGenerationClient(c.config)
	c.GenerationG = NewGenerationGClient(c.config)
	c.GenerationRealtime = NewGenerationRealtimeClient(c.config)
	c.Model = NewModelClient(c.config)
	c.NegativePrompt = NewNegativePromptClient(c.config)
	c.Prompt = NewPromptClient(c.config)
	c.Scheduler = NewSchedulerClient(c.config)
	c.Server = NewServerClient(c.config)
	c.Upscale = NewUpscaleClient(c.config)
	c.UpscaleRealtime = NewUpscaleRealtimeClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Admin:              NewAdminClient(cfg),
		Generation:         NewGenerationClient(cfg),
		GenerationG:        NewGenerationGClient(cfg),
		GenerationRealtime: NewGenerationRealtimeClient(cfg),
		Model:              NewModelClient(cfg),
		NegativePrompt:     NewNegativePromptClient(cfg),
		Prompt:             NewPromptClient(cfg),
		Scheduler:          NewSchedulerClient(cfg),
		Server:             NewServerClient(cfg),
		Upscale:            NewUpscaleClient(cfg),
		UpscaleRealtime:    NewUpscaleRealtimeClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Admin:              NewAdminClient(cfg),
		Generation:         NewGenerationClient(cfg),
		GenerationG:        NewGenerationGClient(cfg),
		GenerationRealtime: NewGenerationRealtimeClient(cfg),
		Model:              NewModelClient(cfg),
		NegativePrompt:     NewNegativePromptClient(cfg),
		Prompt:             NewPromptClient(cfg),
		Scheduler:          NewSchedulerClient(cfg),
		Server:             NewServerClient(cfg),
		Upscale:            NewUpscaleClient(cfg),
		UpscaleRealtime:    NewUpscaleRealtimeClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Admin.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Admin.Use(hooks...)
	c.Generation.Use(hooks...)
	c.GenerationG.Use(hooks...)
	c.GenerationRealtime.Use(hooks...)
	c.Model.Use(hooks...)
	c.NegativePrompt.Use(hooks...)
	c.Prompt.Use(hooks...)
	c.Scheduler.Use(hooks...)
	c.Server.Use(hooks...)
	c.Upscale.Use(hooks...)
	c.UpscaleRealtime.Use(hooks...)
	c.User.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.Admin.Intercept(interceptors...)
	c.Generation.Intercept(interceptors...)
	c.GenerationG.Intercept(interceptors...)
	c.GenerationRealtime.Intercept(interceptors...)
	c.Model.Intercept(interceptors...)
	c.NegativePrompt.Intercept(interceptors...)
	c.Prompt.Intercept(interceptors...)
	c.Scheduler.Intercept(interceptors...)
	c.Server.Intercept(interceptors...)
	c.Upscale.Intercept(interceptors...)
	c.UpscaleRealtime.Intercept(interceptors...)
	c.User.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdminMutation:
		return c.Admin.mutate(ctx, m)
	case *GenerationMutation:
		return c.Generation.mutate(ctx, m)
	case *GenerationGMutation:
		return c.GenerationG.mutate(ctx, m)
	case *GenerationRealtimeMutation:
		return c.GenerationRealtime.mutate(ctx, m)
	case *ModelMutation:
		return c.Model.mutate(ctx, m)
	case *NegativePromptMutation:
		return c.NegativePrompt.mutate(ctx, m)
	case *PromptMutation:
		return c.Prompt.mutate(ctx, m)
	case *SchedulerMutation:
		return c.Scheduler.mutate(ctx, m)
	case *ServerMutation:
		return c.Server.mutate(ctx, m)
	case *UpscaleMutation:
		return c.Upscale.mutate(ctx, m)
	case *UpscaleRealtimeMutation:
		return c.UpscaleRealtime.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdminClient is a client for the Admin schema.
type AdminClient struct {
	config
}

// NewAdminClient returns a client for the Admin from the given config.
func NewAdminClient(c config) *AdminClient {
	return &AdminClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `admin.Hooks(f(g(h())))`.
func (c *AdminClient) Use(hooks ...Hook) {
	c.hooks.Admin = append(c.hooks.Admin, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `admin.Intercept(f(g(h())))`.
func (c *AdminClient) Intercept(interceptors ...Interceptor) {
	c.inters.Admin = append(c.inters.Admin, interceptors...)
}

// Create returns a builder for creating a Admin entity.
func (c *AdminClient) Create() *AdminCreate {
	mutation := newAdminMutation(c.config, OpCreate)
	return &AdminCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Admin entities.
func (c *AdminClient) CreateBulk(builders ...*AdminCreate) *AdminCreateBulk {
	return &AdminCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Admin.
func (c *AdminClient) Update() *AdminUpdate {
	mutation := newAdminMutation(c.config, OpUpdate)
	return &AdminUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminClient) UpdateOne(a *Admin) *AdminUpdateOne {
	mutation := newAdminMutation(c.config, OpUpdateOne, withAdmin(a))
	return &AdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminClient) UpdateOneID(id uuid.UUID) *AdminUpdateOne {
	mutation := newAdminMutation(c.config, OpUpdateOne, withAdminID(id))
	return &AdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Admin.
func (c *AdminClient) Delete() *AdminDelete {
	mutation := newAdminMutation(c.config, OpDelete)
	return &AdminDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdminClient) DeleteOne(a *Admin) *AdminDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdminClient) DeleteOneID(id uuid.UUID) *AdminDeleteOne {
	builder := c.Delete().Where(admin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminDeleteOne{builder}
}

// Query returns a query builder for Admin.
func (c *AdminClient) Query() *AdminQuery {
	return &AdminQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Admin entity by its id.
func (c *AdminClient) Get(ctx context.Context, id uuid.UUID) (*Admin, error) {
	return c.Query().Where(admin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminClient) GetX(ctx context.Context, id uuid.UUID) *Admin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdminClient) Hooks() []Hook {
	return c.hooks.Admin
}

// Interceptors returns the client interceptors.
func (c *AdminClient) Interceptors() []Interceptor {
	return c.inters.Admin
}

func (c *AdminClient) mutate(ctx context.Context, m *AdminMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdminCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdminUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdminDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Admin mutation op: %q", m.Op())
	}
}

// GenerationClient is a client for the Generation schema.
type GenerationClient struct {
	config
}

// NewGenerationClient returns a client for the Generation from the given config.
func NewGenerationClient(c config) *GenerationClient {
	return &GenerationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `generation.Hooks(f(g(h())))`.
func (c *GenerationClient) Use(hooks ...Hook) {
	c.hooks.Generation = append(c.hooks.Generation, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `generation.Intercept(f(g(h())))`.
func (c *GenerationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Generation = append(c.inters.Generation, interceptors...)
}

// Create returns a builder for creating a Generation entity.
func (c *GenerationClient) Create() *GenerationCreate {
	mutation := newGenerationMutation(c.config, OpCreate)
	return &GenerationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Generation entities.
func (c *GenerationClient) CreateBulk(builders ...*GenerationCreate) *GenerationCreateBulk {
	return &GenerationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Generation.
func (c *GenerationClient) Update() *GenerationUpdate {
	mutation := newGenerationMutation(c.config, OpUpdate)
	return &GenerationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenerationClient) UpdateOne(ge *Generation) *GenerationUpdateOne {
	mutation := newGenerationMutation(c.config, OpUpdateOne, withGeneration(ge))
	return &GenerationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenerationClient) UpdateOneID(id uuid.UUID) *GenerationUpdateOne {
	mutation := newGenerationMutation(c.config, OpUpdateOne, withGenerationID(id))
	return &GenerationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Generation.
func (c *GenerationClient) Delete() *GenerationDelete {
	mutation := newGenerationMutation(c.config, OpDelete)
	return &GenerationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GenerationClient) DeleteOne(ge *Generation) *GenerationDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GenerationClient) DeleteOneID(id uuid.UUID) *GenerationDeleteOne {
	builder := c.Delete().Where(generation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenerationDeleteOne{builder}
}

// Query returns a query builder for Generation.
func (c *GenerationClient) Query() *GenerationQuery {
	return &GenerationQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Generation entity by its id.
func (c *GenerationClient) Get(ctx context.Context, id uuid.UUID) (*Generation, error) {
	return c.Query().Where(generation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenerationClient) GetX(ctx context.Context, id uuid.UUID) *Generation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Generation.
func (c *GenerationClient) QueryUser(ge *Generation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generation.Table, generation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generation.UserTable, generation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModel queries the model edge of a Generation.
func (c *GenerationClient) QueryModel(ge *Generation) *ModelQuery {
	query := (&ModelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generation.Table, generation.FieldID, id),
			sqlgraph.To(model.Table, model.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generation.ModelTable, generation.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrompt queries the prompt edge of a Generation.
func (c *GenerationClient) QueryPrompt(ge *Generation) *PromptQuery {
	query := (&PromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generation.Table, generation.FieldID, id),
			sqlgraph.To(prompt.Table, prompt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generation.PromptTable, generation.PromptColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNegativePrompt queries the negative_prompt edge of a Generation.
func (c *GenerationClient) QueryNegativePrompt(ge *Generation) *NegativePromptQuery {
	query := (&NegativePromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generation.Table, generation.FieldID, id),
			sqlgraph.To(negativeprompt.Table, negativeprompt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generation.NegativePromptTable, generation.NegativePromptColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduler queries the scheduler edge of a Generation.
func (c *GenerationClient) QueryScheduler(ge *Generation) *SchedulerQuery {
	query := (&SchedulerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generation.Table, generation.FieldID, id),
			sqlgraph.To(scheduler.Table, scheduler.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generation.SchedulerTable, generation.SchedulerColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenerationClient) Hooks() []Hook {
	return c.hooks.Generation
}

// Interceptors returns the client interceptors.
func (c *GenerationClient) Interceptors() []Interceptor {
	return c.inters.Generation
}

func (c *GenerationClient) mutate(ctx context.Context, m *GenerationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GenerationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GenerationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GenerationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GenerationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Generation mutation op: %q", m.Op())
	}
}

// GenerationGClient is a client for the GenerationG schema.
type GenerationGClient struct {
	config
}

// NewGenerationGClient returns a client for the GenerationG from the given config.
func NewGenerationGClient(c config) *GenerationGClient {
	return &GenerationGClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `generationg.Hooks(f(g(h())))`.
func (c *GenerationGClient) Use(hooks ...Hook) {
	c.hooks.GenerationG = append(c.hooks.GenerationG, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `generationg.Intercept(f(g(h())))`.
func (c *GenerationGClient) Intercept(interceptors ...Interceptor) {
	c.inters.GenerationG = append(c.inters.GenerationG, interceptors...)
}

// Create returns a builder for creating a GenerationG entity.
func (c *GenerationGClient) Create() *GenerationGCreate {
	mutation := newGenerationGMutation(c.config, OpCreate)
	return &GenerationGCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GenerationG entities.
func (c *GenerationGClient) CreateBulk(builders ...*GenerationGCreate) *GenerationGCreateBulk {
	return &GenerationGCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GenerationG.
func (c *GenerationGClient) Update() *GenerationGUpdate {
	mutation := newGenerationGMutation(c.config, OpUpdate)
	return &GenerationGUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenerationGClient) UpdateOne(ge *GenerationG) *GenerationGUpdateOne {
	mutation := newGenerationGMutation(c.config, OpUpdateOne, withGenerationG(ge))
	return &GenerationGUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenerationGClient) UpdateOneID(id uuid.UUID) *GenerationGUpdateOne {
	mutation := newGenerationGMutation(c.config, OpUpdateOne, withGenerationGID(id))
	return &GenerationGUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GenerationG.
func (c *GenerationGClient) Delete() *GenerationGDelete {
	mutation := newGenerationGMutation(c.config, OpDelete)
	return &GenerationGDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GenerationGClient) DeleteOne(ge *GenerationG) *GenerationGDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GenerationGClient) DeleteOneID(id uuid.UUID) *GenerationGDeleteOne {
	builder := c.Delete().Where(generationg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenerationGDeleteOne{builder}
}

// Query returns a query builder for GenerationG.
func (c *GenerationGClient) Query() *GenerationGQuery {
	return &GenerationGQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a GenerationG entity by its id.
func (c *GenerationGClient) Get(ctx context.Context, id uuid.UUID) (*GenerationG, error) {
	return c.Query().Where(generationg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenerationGClient) GetX(ctx context.Context, id uuid.UUID) *GenerationG {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a GenerationG.
func (c *GenerationGClient) QueryUser(ge *GenerationG) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generationg.Table, generationg.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generationg.UserTable, generationg.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModel queries the model edge of a GenerationG.
func (c *GenerationGClient) QueryModel(ge *GenerationG) *ModelQuery {
	query := (&ModelClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generationg.Table, generationg.FieldID, id),
			sqlgraph.To(model.Table, model.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generationg.ModelTable, generationg.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrompt queries the prompt edge of a GenerationG.
func (c *GenerationGClient) QueryPrompt(ge *GenerationG) *PromptQuery {
	query := (&PromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generationg.Table, generationg.FieldID, id),
			sqlgraph.To(prompt.Table, prompt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generationg.PromptTable, generationg.PromptColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNegativePrompt queries the negative_prompt edge of a GenerationG.
func (c *GenerationGClient) QueryNegativePrompt(ge *GenerationG) *NegativePromptQuery {
	query := (&NegativePromptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generationg.Table, generationg.FieldID, id),
			sqlgraph.To(negativeprompt.Table, negativeprompt.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generationg.NegativePromptTable, generationg.NegativePromptColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduler queries the scheduler edge of a GenerationG.
func (c *GenerationGClient) QueryScheduler(ge *GenerationG) *SchedulerQuery {
	query := (&SchedulerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generationg.Table, generationg.FieldID, id),
			sqlgraph.To(scheduler.Table, scheduler.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generationg.SchedulerTable, generationg.SchedulerColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GenerationGClient) Hooks() []Hook {
	return c.hooks.GenerationG
}

// Interceptors returns the client interceptors.
func (c *GenerationGClient) Interceptors() []Interceptor {
	return c.inters.GenerationG
}

func (c *GenerationGClient) mutate(ctx context.Context, m *GenerationGMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GenerationGCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GenerationGUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GenerationGUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GenerationGDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GenerationG mutation op: %q", m.Op())
	}
}

// GenerationRealtimeClient is a client for the GenerationRealtime schema.
type GenerationRealtimeClient struct {
	config
}

// NewGenerationRealtimeClient returns a client for the GenerationRealtime from the given config.
func NewGenerationRealtimeClient(c config) *GenerationRealtimeClient {
	return &GenerationRealtimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `generationrealtime.Hooks(f(g(h())))`.
func (c *GenerationRealtimeClient) Use(hooks ...Hook) {
	c.hooks.GenerationRealtime = append(c.hooks.GenerationRealtime, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `generationrealtime.Intercept(f(g(h())))`.
func (c *GenerationRealtimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.GenerationRealtime = append(c.inters.GenerationRealtime, interceptors...)
}

// Create returns a builder for creating a GenerationRealtime entity.
func (c *GenerationRealtimeClient) Create() *GenerationRealtimeCreate {
	mutation := newGenerationRealtimeMutation(c.config, OpCreate)
	return &GenerationRealtimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GenerationRealtime entities.
func (c *GenerationRealtimeClient) CreateBulk(builders ...*GenerationRealtimeCreate) *GenerationRealtimeCreateBulk {
	return &GenerationRealtimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GenerationRealtime.
func (c *GenerationRealtimeClient) Update() *GenerationRealtimeUpdate {
	mutation := newGenerationRealtimeMutation(c.config, OpUpdate)
	return &GenerationRealtimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GenerationRealtimeClient) UpdateOne(gr *GenerationRealtime) *GenerationRealtimeUpdateOne {
	mutation := newGenerationRealtimeMutation(c.config, OpUpdateOne, withGenerationRealtime(gr))
	return &GenerationRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GenerationRealtimeClient) UpdateOneID(id uuid.UUID) *GenerationRealtimeUpdateOne {
	mutation := newGenerationRealtimeMutation(c.config, OpUpdateOne, withGenerationRealtimeID(id))
	return &GenerationRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GenerationRealtime.
func (c *GenerationRealtimeClient) Delete() *GenerationRealtimeDelete {
	mutation := newGenerationRealtimeMutation(c.config, OpDelete)
	return &GenerationRealtimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GenerationRealtimeClient) DeleteOne(gr *GenerationRealtime) *GenerationRealtimeDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GenerationRealtimeClient) DeleteOneID(id uuid.UUID) *GenerationRealtimeDeleteOne {
	builder := c.Delete().Where(generationrealtime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GenerationRealtimeDeleteOne{builder}
}

// Query returns a query builder for GenerationRealtime.
func (c *GenerationRealtimeClient) Query() *GenerationRealtimeQuery {
	return &GenerationRealtimeQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a GenerationRealtime entity by its id.
func (c *GenerationRealtimeClient) Get(ctx context.Context, id uuid.UUID) (*GenerationRealtime, error) {
	return c.Query().Where(generationrealtime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GenerationRealtimeClient) GetX(ctx context.Context, id uuid.UUID) *GenerationRealtime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GenerationRealtimeClient) Hooks() []Hook {
	return c.hooks.GenerationRealtime
}

// Interceptors returns the client interceptors.
func (c *GenerationRealtimeClient) Interceptors() []Interceptor {
	return c.inters.GenerationRealtime
}

func (c *GenerationRealtimeClient) mutate(ctx context.Context, m *GenerationRealtimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GenerationRealtimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GenerationRealtimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GenerationRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GenerationRealtimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GenerationRealtime mutation op: %q", m.Op())
	}
}

// ModelClient is a client for the Model schema.
type ModelClient struct {
	config
}

// NewModelClient returns a client for the Model from the given config.
func NewModelClient(c config) *ModelClient {
	return &ModelClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `model.Hooks(f(g(h())))`.
func (c *ModelClient) Use(hooks ...Hook) {
	c.hooks.Model = append(c.hooks.Model, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `model.Intercept(f(g(h())))`.
func (c *ModelClient) Intercept(interceptors ...Interceptor) {
	c.inters.Model = append(c.inters.Model, interceptors...)
}

// Create returns a builder for creating a Model entity.
func (c *ModelClient) Create() *ModelCreate {
	mutation := newModelMutation(c.config, OpCreate)
	return &ModelCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Model entities.
func (c *ModelClient) CreateBulk(builders ...*ModelCreate) *ModelCreateBulk {
	return &ModelCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Model.
func (c *ModelClient) Update() *ModelUpdate {
	mutation := newModelMutation(c.config, OpUpdate)
	return &ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModelClient) UpdateOne(m *Model) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModel(m))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModelClient) UpdateOneID(id uuid.UUID) *ModelUpdateOne {
	mutation := newModelMutation(c.config, OpUpdateOne, withModelID(id))
	return &ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Model.
func (c *ModelClient) Delete() *ModelDelete {
	mutation := newModelMutation(c.config, OpDelete)
	return &ModelDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ModelClient) DeleteOne(m *Model) *ModelDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ModelClient) DeleteOneID(id uuid.UUID) *ModelDeleteOne {
	builder := c.Delete().Where(model.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModelDeleteOne{builder}
}

// Query returns a query builder for Model.
func (c *ModelClient) Query() *ModelQuery {
	return &ModelQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Model entity by its id.
func (c *ModelClient) Get(ctx context.Context, id uuid.UUID) (*Model, error) {
	return c.Query().Where(model.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModelClient) GetX(ctx context.Context, id uuid.UUID) *Model {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGeneration queries the generation edge of a Model.
func (c *ModelClient) QueryGeneration(m *Model) *GenerationQuery {
	query := (&GenerationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(model.Table, model.FieldID, id),
			sqlgraph.To(generation.Table, generation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, model.GenerationTable, model.GenerationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerationG queries the generation_g edge of a Model.
func (c *ModelClient) QueryGenerationG(m *Model) *GenerationGQuery {
	query := (&GenerationGClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(model.Table, model.FieldID, id),
			sqlgraph.To(generationg.Table, generationg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, model.GenerationGTable, model.GenerationGColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModelClient) Hooks() []Hook {
	return c.hooks.Model
}

// Interceptors returns the client interceptors.
func (c *ModelClient) Interceptors() []Interceptor {
	return c.inters.Model
}

func (c *ModelClient) mutate(ctx context.Context, m *ModelMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ModelCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ModelUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ModelUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ModelDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Model mutation op: %q", m.Op())
	}
}

// NegativePromptClient is a client for the NegativePrompt schema.
type NegativePromptClient struct {
	config
}

// NewNegativePromptClient returns a client for the NegativePrompt from the given config.
func NewNegativePromptClient(c config) *NegativePromptClient {
	return &NegativePromptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `negativeprompt.Hooks(f(g(h())))`.
func (c *NegativePromptClient) Use(hooks ...Hook) {
	c.hooks.NegativePrompt = append(c.hooks.NegativePrompt, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `negativeprompt.Intercept(f(g(h())))`.
func (c *NegativePromptClient) Intercept(interceptors ...Interceptor) {
	c.inters.NegativePrompt = append(c.inters.NegativePrompt, interceptors...)
}

// Create returns a builder for creating a NegativePrompt entity.
func (c *NegativePromptClient) Create() *NegativePromptCreate {
	mutation := newNegativePromptMutation(c.config, OpCreate)
	return &NegativePromptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NegativePrompt entities.
func (c *NegativePromptClient) CreateBulk(builders ...*NegativePromptCreate) *NegativePromptCreateBulk {
	return &NegativePromptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NegativePrompt.
func (c *NegativePromptClient) Update() *NegativePromptUpdate {
	mutation := newNegativePromptMutation(c.config, OpUpdate)
	return &NegativePromptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NegativePromptClient) UpdateOne(np *NegativePrompt) *NegativePromptUpdateOne {
	mutation := newNegativePromptMutation(c.config, OpUpdateOne, withNegativePrompt(np))
	return &NegativePromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NegativePromptClient) UpdateOneID(id uuid.UUID) *NegativePromptUpdateOne {
	mutation := newNegativePromptMutation(c.config, OpUpdateOne, withNegativePromptID(id))
	return &NegativePromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NegativePrompt.
func (c *NegativePromptClient) Delete() *NegativePromptDelete {
	mutation := newNegativePromptMutation(c.config, OpDelete)
	return &NegativePromptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NegativePromptClient) DeleteOne(np *NegativePrompt) *NegativePromptDeleteOne {
	return c.DeleteOneID(np.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NegativePromptClient) DeleteOneID(id uuid.UUID) *NegativePromptDeleteOne {
	builder := c.Delete().Where(negativeprompt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NegativePromptDeleteOne{builder}
}

// Query returns a query builder for NegativePrompt.
func (c *NegativePromptClient) Query() *NegativePromptQuery {
	return &NegativePromptQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a NegativePrompt entity by its id.
func (c *NegativePromptClient) Get(ctx context.Context, id uuid.UUID) (*NegativePrompt, error) {
	return c.Query().Where(negativeprompt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NegativePromptClient) GetX(ctx context.Context, id uuid.UUID) *NegativePrompt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGeneration queries the generation edge of a NegativePrompt.
func (c *NegativePromptClient) QueryGeneration(np *NegativePrompt) *GenerationQuery {
	query := (&GenerationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := np.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(negativeprompt.Table, negativeprompt.FieldID, id),
			sqlgraph.To(generation.Table, generation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, negativeprompt.GenerationTable, negativeprompt.GenerationColumn),
		)
		fromV = sqlgraph.Neighbors(np.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerationG queries the generation_g edge of a NegativePrompt.
func (c *NegativePromptClient) QueryGenerationG(np *NegativePrompt) *GenerationGQuery {
	query := (&GenerationGClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := np.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(negativeprompt.Table, negativeprompt.FieldID, id),
			sqlgraph.To(generationg.Table, generationg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, negativeprompt.GenerationGTable, negativeprompt.GenerationGColumn),
		)
		fromV = sqlgraph.Neighbors(np.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NegativePromptClient) Hooks() []Hook {
	return c.hooks.NegativePrompt
}

// Interceptors returns the client interceptors.
func (c *NegativePromptClient) Interceptors() []Interceptor {
	return c.inters.NegativePrompt
}

func (c *NegativePromptClient) mutate(ctx context.Context, m *NegativePromptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NegativePromptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NegativePromptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NegativePromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NegativePromptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NegativePrompt mutation op: %q", m.Op())
	}
}

// PromptClient is a client for the Prompt schema.
type PromptClient struct {
	config
}

// NewPromptClient returns a client for the Prompt from the given config.
func NewPromptClient(c config) *PromptClient {
	return &PromptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prompt.Hooks(f(g(h())))`.
func (c *PromptClient) Use(hooks ...Hook) {
	c.hooks.Prompt = append(c.hooks.Prompt, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prompt.Intercept(f(g(h())))`.
func (c *PromptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Prompt = append(c.inters.Prompt, interceptors...)
}

// Create returns a builder for creating a Prompt entity.
func (c *PromptClient) Create() *PromptCreate {
	mutation := newPromptMutation(c.config, OpCreate)
	return &PromptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Prompt entities.
func (c *PromptClient) CreateBulk(builders ...*PromptCreate) *PromptCreateBulk {
	return &PromptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Prompt.
func (c *PromptClient) Update() *PromptUpdate {
	mutation := newPromptMutation(c.config, OpUpdate)
	return &PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromptClient) UpdateOne(pr *Prompt) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPrompt(pr))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromptClient) UpdateOneID(id uuid.UUID) *PromptUpdateOne {
	mutation := newPromptMutation(c.config, OpUpdateOne, withPromptID(id))
	return &PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prompt.
func (c *PromptClient) Delete() *PromptDelete {
	mutation := newPromptMutation(c.config, OpDelete)
	return &PromptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromptClient) DeleteOne(pr *Prompt) *PromptDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromptClient) DeleteOneID(id uuid.UUID) *PromptDeleteOne {
	builder := c.Delete().Where(prompt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromptDeleteOne{builder}
}

// Query returns a query builder for Prompt.
func (c *PromptClient) Query() *PromptQuery {
	return &PromptQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Prompt entity by its id.
func (c *PromptClient) Get(ctx context.Context, id uuid.UUID) (*Prompt, error) {
	return c.Query().Where(prompt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromptClient) GetX(ctx context.Context, id uuid.UUID) *Prompt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGeneration queries the generation edge of a Prompt.
func (c *PromptClient) QueryGeneration(pr *Prompt) *GenerationQuery {
	query := (&GenerationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prompt.Table, prompt.FieldID, id),
			sqlgraph.To(generation.Table, generation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prompt.GenerationTable, prompt.GenerationColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerationG queries the generation_g edge of a Prompt.
func (c *PromptClient) QueryGenerationG(pr *Prompt) *GenerationGQuery {
	query := (&GenerationGClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prompt.Table, prompt.FieldID, id),
			sqlgraph.To(generationg.Table, generationg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, prompt.GenerationGTable, prompt.GenerationGColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromptClient) Hooks() []Hook {
	return c.hooks.Prompt
}

// Interceptors returns the client interceptors.
func (c *PromptClient) Interceptors() []Interceptor {
	return c.inters.Prompt
}

func (c *PromptClient) mutate(ctx context.Context, m *PromptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Prompt mutation op: %q", m.Op())
	}
}

// SchedulerClient is a client for the Scheduler schema.
type SchedulerClient struct {
	config
}

// NewSchedulerClient returns a client for the Scheduler from the given config.
func NewSchedulerClient(c config) *SchedulerClient {
	return &SchedulerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduler.Hooks(f(g(h())))`.
func (c *SchedulerClient) Use(hooks ...Hook) {
	c.hooks.Scheduler = append(c.hooks.Scheduler, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduler.Intercept(f(g(h())))`.
func (c *SchedulerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scheduler = append(c.inters.Scheduler, interceptors...)
}

// Create returns a builder for creating a Scheduler entity.
func (c *SchedulerClient) Create() *SchedulerCreate {
	mutation := newSchedulerMutation(c.config, OpCreate)
	return &SchedulerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scheduler entities.
func (c *SchedulerClient) CreateBulk(builders ...*SchedulerCreate) *SchedulerCreateBulk {
	return &SchedulerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scheduler.
func (c *SchedulerClient) Update() *SchedulerUpdate {
	mutation := newSchedulerMutation(c.config, OpUpdate)
	return &SchedulerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SchedulerClient) UpdateOne(s *Scheduler) *SchedulerUpdateOne {
	mutation := newSchedulerMutation(c.config, OpUpdateOne, withScheduler(s))
	return &SchedulerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SchedulerClient) UpdateOneID(id uuid.UUID) *SchedulerUpdateOne {
	mutation := newSchedulerMutation(c.config, OpUpdateOne, withSchedulerID(id))
	return &SchedulerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scheduler.
func (c *SchedulerClient) Delete() *SchedulerDelete {
	mutation := newSchedulerMutation(c.config, OpDelete)
	return &SchedulerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SchedulerClient) DeleteOne(s *Scheduler) *SchedulerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SchedulerClient) DeleteOneID(id uuid.UUID) *SchedulerDeleteOne {
	builder := c.Delete().Where(scheduler.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SchedulerDeleteOne{builder}
}

// Query returns a query builder for Scheduler.
func (c *SchedulerClient) Query() *SchedulerQuery {
	return &SchedulerQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Scheduler entity by its id.
func (c *SchedulerClient) Get(ctx context.Context, id uuid.UUID) (*Scheduler, error) {
	return c.Query().Where(scheduler.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SchedulerClient) GetX(ctx context.Context, id uuid.UUID) *Scheduler {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGeneration queries the generation edge of a Scheduler.
func (c *SchedulerClient) QueryGeneration(s *Scheduler) *GenerationQuery {
	query := (&GenerationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduler.Table, scheduler.FieldID, id),
			sqlgraph.To(generation.Table, generation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scheduler.GenerationTable, scheduler.GenerationColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerationG queries the generation_g edge of a Scheduler.
func (c *SchedulerClient) QueryGenerationG(s *Scheduler) *GenerationGQuery {
	query := (&GenerationGClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduler.Table, scheduler.FieldID, id),
			sqlgraph.To(generationg.Table, generationg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scheduler.GenerationGTable, scheduler.GenerationGColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SchedulerClient) Hooks() []Hook {
	return c.hooks.Scheduler
}

// Interceptors returns the client interceptors.
func (c *SchedulerClient) Interceptors() []Interceptor {
	return c.inters.Scheduler
}

func (c *SchedulerClient) mutate(ctx context.Context, m *SchedulerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SchedulerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SchedulerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SchedulerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SchedulerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Scheduler mutation op: %q", m.Op())
	}
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `server.Intercept(f(g(h())))`.
func (c *ServerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Server = append(c.inters.Server, interceptors...)
}

// Create returns a builder for creating a Server entity.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(s *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(s))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id uuid.UUID) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerClient) DeleteOne(s *Server) *ServerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerClient) DeleteOneID(id uuid.UUID) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id uuid.UUID) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id uuid.UUID) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// Interceptors returns the client interceptors.
func (c *ServerClient) Interceptors() []Interceptor {
	return c.inters.Server
}

func (c *ServerClient) mutate(ctx context.Context, m *ServerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Server mutation op: %q", m.Op())
	}
}

// UpscaleClient is a client for the Upscale schema.
type UpscaleClient struct {
	config
}

// NewUpscaleClient returns a client for the Upscale from the given config.
func NewUpscaleClient(c config) *UpscaleClient {
	return &UpscaleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `upscale.Hooks(f(g(h())))`.
func (c *UpscaleClient) Use(hooks ...Hook) {
	c.hooks.Upscale = append(c.hooks.Upscale, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `upscale.Intercept(f(g(h())))`.
func (c *UpscaleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Upscale = append(c.inters.Upscale, interceptors...)
}

// Create returns a builder for creating a Upscale entity.
func (c *UpscaleClient) Create() *UpscaleCreate {
	mutation := newUpscaleMutation(c.config, OpCreate)
	return &UpscaleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Upscale entities.
func (c *UpscaleClient) CreateBulk(builders ...*UpscaleCreate) *UpscaleCreateBulk {
	return &UpscaleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Upscale.
func (c *UpscaleClient) Update() *UpscaleUpdate {
	mutation := newUpscaleMutation(c.config, OpUpdate)
	return &UpscaleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UpscaleClient) UpdateOne(u *Upscale) *UpscaleUpdateOne {
	mutation := newUpscaleMutation(c.config, OpUpdateOne, withUpscale(u))
	return &UpscaleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UpscaleClient) UpdateOneID(id uuid.UUID) *UpscaleUpdateOne {
	mutation := newUpscaleMutation(c.config, OpUpdateOne, withUpscaleID(id))
	return &UpscaleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Upscale.
func (c *UpscaleClient) Delete() *UpscaleDelete {
	mutation := newUpscaleMutation(c.config, OpDelete)
	return &UpscaleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UpscaleClient) DeleteOne(u *Upscale) *UpscaleDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UpscaleClient) DeleteOneID(id uuid.UUID) *UpscaleDeleteOne {
	builder := c.Delete().Where(upscale.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UpscaleDeleteOne{builder}
}

// Query returns a query builder for Upscale.
func (c *UpscaleClient) Query() *UpscaleQuery {
	return &UpscaleQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Upscale entity by its id.
func (c *UpscaleClient) Get(ctx context.Context, id uuid.UUID) (*Upscale, error) {
	return c.Query().Where(upscale.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UpscaleClient) GetX(ctx context.Context, id uuid.UUID) *Upscale {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Upscale.
func (c *UpscaleClient) QueryUser(u *Upscale) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(upscale.Table, upscale.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, upscale.UserTable, upscale.UserColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UpscaleClient) Hooks() []Hook {
	return c.hooks.Upscale
}

// Interceptors returns the client interceptors.
func (c *UpscaleClient) Interceptors() []Interceptor {
	return c.inters.Upscale
}

func (c *UpscaleClient) mutate(ctx context.Context, m *UpscaleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UpscaleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UpscaleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UpscaleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UpscaleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Upscale mutation op: %q", m.Op())
	}
}

// UpscaleRealtimeClient is a client for the UpscaleRealtime schema.
type UpscaleRealtimeClient struct {
	config
}

// NewUpscaleRealtimeClient returns a client for the UpscaleRealtime from the given config.
func NewUpscaleRealtimeClient(c config) *UpscaleRealtimeClient {
	return &UpscaleRealtimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `upscalerealtime.Hooks(f(g(h())))`.
func (c *UpscaleRealtimeClient) Use(hooks ...Hook) {
	c.hooks.UpscaleRealtime = append(c.hooks.UpscaleRealtime, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `upscalerealtime.Intercept(f(g(h())))`.
func (c *UpscaleRealtimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UpscaleRealtime = append(c.inters.UpscaleRealtime, interceptors...)
}

// Create returns a builder for creating a UpscaleRealtime entity.
func (c *UpscaleRealtimeClient) Create() *UpscaleRealtimeCreate {
	mutation := newUpscaleRealtimeMutation(c.config, OpCreate)
	return &UpscaleRealtimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UpscaleRealtime entities.
func (c *UpscaleRealtimeClient) CreateBulk(builders ...*UpscaleRealtimeCreate) *UpscaleRealtimeCreateBulk {
	return &UpscaleRealtimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UpscaleRealtime.
func (c *UpscaleRealtimeClient) Update() *UpscaleRealtimeUpdate {
	mutation := newUpscaleRealtimeMutation(c.config, OpUpdate)
	return &UpscaleRealtimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UpscaleRealtimeClient) UpdateOne(ur *UpscaleRealtime) *UpscaleRealtimeUpdateOne {
	mutation := newUpscaleRealtimeMutation(c.config, OpUpdateOne, withUpscaleRealtime(ur))
	return &UpscaleRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UpscaleRealtimeClient) UpdateOneID(id uuid.UUID) *UpscaleRealtimeUpdateOne {
	mutation := newUpscaleRealtimeMutation(c.config, OpUpdateOne, withUpscaleRealtimeID(id))
	return &UpscaleRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UpscaleRealtime.
func (c *UpscaleRealtimeClient) Delete() *UpscaleRealtimeDelete {
	mutation := newUpscaleRealtimeMutation(c.config, OpDelete)
	return &UpscaleRealtimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UpscaleRealtimeClient) DeleteOne(ur *UpscaleRealtime) *UpscaleRealtimeDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UpscaleRealtimeClient) DeleteOneID(id uuid.UUID) *UpscaleRealtimeDeleteOne {
	builder := c.Delete().Where(upscalerealtime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UpscaleRealtimeDeleteOne{builder}
}

// Query returns a query builder for UpscaleRealtime.
func (c *UpscaleRealtimeClient) Query() *UpscaleRealtimeQuery {
	return &UpscaleRealtimeQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a UpscaleRealtime entity by its id.
func (c *UpscaleRealtimeClient) Get(ctx context.Context, id uuid.UUID) (*UpscaleRealtime, error) {
	return c.Query().Where(upscalerealtime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UpscaleRealtimeClient) GetX(ctx context.Context, id uuid.UUID) *UpscaleRealtime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UpscaleRealtimeClient) Hooks() []Hook {
	return c.hooks.UpscaleRealtime
}

// Interceptors returns the client interceptors.
func (c *UpscaleRealtimeClient) Interceptors() []Interceptor {
	return c.inters.UpscaleRealtime
}

func (c *UpscaleRealtimeClient) mutate(ctx context.Context, m *UpscaleRealtimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UpscaleRealtimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UpscaleRealtimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UpscaleRealtimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UpscaleRealtimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UpscaleRealtime mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUpscale queries the upscale edge of a User.
func (c *UserClient) QueryUpscale(u *User) *UpscaleQuery {
	query := (&UpscaleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(upscale.Table, upscale.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UpscaleTable, user.UpscaleColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGeneration queries the generation edge of a User.
func (c *UserClient) QueryGeneration(u *User) *GenerationQuery {
	query := (&GenerationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(generation.Table, generation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GenerationTable, user.GenerationColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerationG queries the generation_g edge of a User.
func (c *UserClient) QueryGenerationG(u *User) *GenerationGQuery {
	query := (&GenerationGClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(generationg.Table, generationg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GenerationGTable, user.GenerationGColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}
